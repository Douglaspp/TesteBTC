# -*- coding: utf-8 -*-

import tensorflow as tf
tf.config.run_functions_eagerly(True)
tf.data.experimental.enable_debug_mode()

import pandas as pd
import numpy as np
from binance.client import Client
from binance.enums import *
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional
from datetime import datetime, timedelta
from tqdm import tqdm
from tensorflow.keras.layers import Flatten


# Definição dos parâmetros
API_KEY = 'hruZgjj2PS9WCvNrT3scR726HlMLc0vnWWkLceUigMdbJECG2ay331Euh4qeDSjM'
SECRET_KEY = 'ZReFgghppeiV6qQFwojT5EczFGjANLGOzkL7Q35j5P8hGopILGDnfY3queFSXfFO'
PAIR = 'BTCUSDT'
BATCH_SIZE = 32
EPOCHS = 25
INTERVAL = Client.KLINE_INTERVAL_1HOUR  # intervalo de 1 HORA
LSTM_WINDOW = 60 # janela de 60 dias para a LSTM

client = Client(API_KEY, SECRET_KEY)

inicio = input('Insira a data de inicio para amostragem (mm/dd/yyyy): ')
fim = input('Insira a data de fim para amostragem (mm/dd/yyyy): ')

# Converte as datas para objeto datetime
inicio_dt = datetime.strptime(inicio, '%m/%d/%Y')
inicio_ant = (inicio_dt - timedelta(days=20)).strftime('%m/%d/%Y')
fim_dt = datetime.strptime(fim, '%m/%d/%Y')

# Calcula a quantidade de dias da amostragem
dias_amostra = (fim_dt - inicio_dt).days

# Faz a leitura dos dados do par BTCUSDT na Binance
print("Carregando dados da API...")
klines = client.get_historical_klines(PAIR, INTERVAL, inicio_ant, fim)

# Cria a barra de progresso
pbar = tqdm(total=len(klines))

df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

# Converte as strings de timestamp para objetos datetime
for kline in klines:
    timestamp = pd.to_datetime(kline[0], unit='ms')
    close = float(kline[4])
    df = df._append({'Data': timestamp, 'Close': close}, ignore_index=True)
    pbar.update(1)
      
df = df[['timestamp', 'close']]
df.columns = ['Data', 'Close']

# Fecha a barra de progresso
pbar.close()

# Imprime as primeiras linhas do objeto data
print(data.head())

# Cria um DataFrame do Pandas com os dados e renomeia as colunas
df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'])

# Converte as colunas relevantes para números de ponto flutuante
df['close'] = df['close'].astype(float)

# Normaliza os dados com o MinMaxScaler
scaler = MinMaxScaler()
data = scaler.fit_transform(df[['close']])

# Cria um DataFrame do Pandas com os dados normalizados
df_norm = pd.DataFrame(data, columns=['close'])

# Converte o array NumPy em um objeto Pandas Series
close_series = pd.Series(data[:, 0])

# Cria as sequências de dados para a LSTM
def create_sequences(data, window, bands):
    xs = []
    ys = []

    for i in range(window, len(data)):
        x = data[i-window:i, :]
        x = np.concatenate((x, bands[i-window:i]), axis=1)
        xs.append(x)
        ys.append(data[i, 0])

    return np.array(xs), np.array(ys)

#Solicita as datas de início e fim da previsão
inicio_prev = input('Insira a data de inicio para previsao (mm/dd/yyyy): ')
fim_prev = input('Insira a data de fim para previsao (mm/dd/yyyy): ')


#Converte as datas para objetos datetime
df = pd.DataFrame(columns=['timestamp', 'close'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
inicio_prev_dt = datetime.strptime(inicio_prev, '%m/%d/%Y')
fim_prev_dt = datetime.strptime(fim_prev, '%m/%d/%Y') + pd.DateOffset(days=1)

#Calcula a quantidade de dias para a previsão
dias_prev = (fim_prev_dt - inicio_prev_dt).days

# Verifica se o valor de dias_prev é maior do que o número de linhas em data
if dias_prev > len(data):
    print("Erro: dias_prev e maior do que o numero de linhas em data.")

# Separa os dados de treino e teste
train_data = data[:-dias_prev]
test_data = data[-LSTM_WINDOW:]
test_data = np.vstack((train_data[-LSTM_WINDOW:], test_data))

rolling_mean = close_series.rolling(window=20).mean()
rolling_std = close_series.rolling(window=20).std()
upper_band = rolling_mean + (rolling_std * 2)
lower_band = rolling_mean - (rolling_std * 2)

# Adiciona um valor NaN no início do DataFrame
rolling_mean = pd.concat([pd.Series(np.nan), rolling_mean]).reset_index(drop=True)
rolling_std = pd.concat([pd.Series(np.nan), rolling_std]).reset_index(drop=True)
upper_band = pd.concat([pd.Series(np.nan), upper_band]).reset_index(drop=True)
lower_band = pd.concat([pd.Series(np.nan), lower_band]).reset_index(drop=True)

print("Rolling Mean Sequence:\n", rolling_mean_seq)
print("Upper Band Sequence:\n", upper_band_seq)
print("Lower Band Sequence:\n", lower_band_seq)

# Preenche o valor NaN com o valor de abertura do dia atual
rolling_mean = rolling_mean.fillna(df['close'].iloc[0])
rolling_std = rolling_std.fillna(df['close'].iloc[0])
upper_band = upper_band.fillna(df['close'].iloc[0])
lower_band = lower_band.fillna(df['close'].iloc[0])

# Ajusta as dimensões das bandas de Bollinger para os dados de treino
rolling_mean = rolling_mean[LSTM_WINDOW:]
rolling_std = rolling_std[LSTM_WINDOW:]
upper_band = upper_band[LSTM_WINDOW:]
lower_band = lower_band[LSTM_WINDOW:]

# Cria as sequências de dados para a LSTM com as bandas de Bollinger
rolling_mean_seq = np.array([rolling_mean[i-LSTM_WINDOW:i] for i in range(LSTM_WINDOW, len(rolling_mean))])
upper_band_seq = np.array([upper_band[i-LSTM_WINDOW:i] for i in range(LSTM_WINDOW, len(upper_band))])
lower_band_seq = np.array([lower_band[i-LSTM_WINDOW:i] for i in range(LSTM_WINDOW, len(lower_band))])
x_train, y_train = create_sequences(train_data, LSTM_WINDOW, np.concatenate((rolling_mean_seq, upper_band_seq, lower_band_seq), axis=1))
x_test, y_test = create_sequences(test_data, LSTM_WINDOW, np.concatenate((rolling_mean_seq[-LSTM_WINDOW:], upper_band_seq[-LSTM_WINDOW:], lower_band_seq[-LSTM_WINDOW:]), axis=1))
x_train = np.concatenate((x_train, np.zeros((len(x_train), LSTM_WINDOW, 3))), axis=2)
x_test = np.concatenate((x_test, np.zeros((len(x_test), LSTM_WINDOW, 3))), axis=2)
x_train[:, :, 1] = rolling_mean_seq
x_train[:, :, 2] = upper_band_seq
x_train[:, :, 3] = lower_band_seq
x_test[:, :, 1] = np.tile(rolling_mean_seq[-1], (len(x_test), 1))
x_test[:, :, 2] = np.tile(upper_band_seq[-1], (len(x_test), 1))
x_test[:, :, 3] = np.tile(lower_band_seq[-1], (len(x_test), 1))

model = Sequential()
model.add(Bidirectional(LSTM(256, input_shape=(LSTM_WINDOW, 5))))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')

# Treina o modelo
model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=EPOCHS, verbose=1)

#Faz a previsão dos valores do par de negociação para os próximos dias_prev dias
last_sequence = x_test[1]
predicted_values = []

print('x_test shape:', x_test.shape)
print('y_test shape:', y_test.shape)

for i in range(len(x_test)):
    predicted_value = model.predict(x_test[i].reshape(1, LSTM_WINDOW, 5))
    predicted_values.append(predicted_value[0][0])
    if len(predicted_values) == len(y_test):
        break

# Ajusta o tamanho do array de valores previstos para o tamanho do array de valores reais
if len(predicted_values) > len(y_test):
    predicted_values = predicted_values[:len(y_test)]
elif len(predicted_values) < len(y_test):
    y_test = y_test[:len(predicted_values)]

#Reverte a normalização dos dados
predicted_values = np.array(predicted_values).reshape(-1, 1)
predicted_values = scaler.inverse_transform(predicted_values)
y_test = scaler.inverse_transform(np.array(y_test).reshape(-1, 1))

if len(predicted_values) > len(y_test):
    predicted_values = predicted_values[:len(y_test)]
elif len(predicted_values) < len(y_test):
    y_test = y_test[:len(predicted_values)]

print(len(pd.date_range(start=inicio_prev_dt, end=fim_prev_dt, freq='D')[:-1]))
print(len(predicted_values.ravel()))
print(len(y_test.ravel()))

dates = pd.date_range(start=inicio_prev_dt, end=fim_prev_dt, freq='D')[:-1]

# Ajusta o tamanho do array de valores previstos para o tamanho do array de valores reais
if len(predicted_values) > len(y_test):
    predicted_values = predicted_values[:len(y_test)]
elif len(predicted_values) < len(y_test):
    y_test = y_test[:len(predicted_values)]

# Cria um DataFrame para exibir os valores previstos e os valores reais dos dias de previsão
df_pred = pd.DataFrame({'Data': pd.date_range(start=inicio_prev_dt, end=fim_prev_dt, freq='D')[:len(predicted_values)], 'Valor Previsto': predicted_values.ravel()})
df_real = pd.DataFrame({'Data': pd.date_range(start=inicio_prev_dt, end=fim_prev_dt, freq='D')[:len(y_test)], 'Valor Real': y_test.ravel()})

# Crie uma máscara booleana para identificar as datas futuras
mask = df_real['Data'] >= datetime.now()

# Aplique a máscara e substitua os valores futuros por NaN
df_real.loc[mask, 'Valor Real'] = np.nan

# Cria o DataFrame final mesclando df_pred e df_real
df_final = pd.merge(df_pred, df_real, on='Data')

# Exibe o resultado
print(df_final)
